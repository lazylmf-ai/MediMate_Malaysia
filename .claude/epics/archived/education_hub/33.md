---
name: Offline & Sync Capability
status: open
created: 2025-10-01T11:05:51Z
updated: 2025-10-02T12:55:17Z
github: https://github.com/lazylmf-ai/MediMate_Malaysia/issues/33
depends_on: [30, 31]
parallel: true
conflicts_with: []
---

# Task 034: Offline & Sync Capability

## Description

Implement offline-first architecture for education content, enabling users to download articles and videos for offline access and automatically sync progress when connectivity is restored. This ensures the Education Hub remains functional in areas with poor internet connectivity, critical for elderly users in rural Malaysia.

**Scope:**
- Extend existing offline sync infrastructure for education content
- Download manager UI for selecting and managing offline content
- Local caching with 7-day TTL (time-to-live)
- Background sync service for progress and achievements
- Storage management and cleanup utilities
- Download queue with pause/resume functionality

## Acceptance Criteria

- [ ] Users can download individual articles and videos for offline access
- [ ] Download manager UI shows download progress and storage usage
- [ ] Downloaded content remains accessible for 7 days without connectivity
- [ ] Content automatically refreshes when online and TTL expires
- [ ] User progress tracked offline and synced when connectivity restored
- [ ] Quiz submissions queued offline and synced to backend
- [ ] Achievement unlocks work offline with deferred notifications
- [ ] Storage quota management prevents device storage overflow
- [ ] Users can manually delete cached content to free space
- [ ] Download queue supports pause, resume, and cancel operations
- [ ] Background sync runs periodically without draining battery
- [ ] Offline indicator displayed in UI when no connectivity

## Technical Details

### Offline Storage Architecture

**Storage Strategy:**
```typescript
// frontend/src/services/offlineStorageService.ts
import AsyncStorage from '@react-native-async-storage/async-storage';
import RNFS from 'react-native-fs';

interface CachedContent {
  id: string;
  type: 'article' | 'video';
  downloadedAt: string;
  expiresAt: string;
  filePath: string;
  metadata: {
    title: Record<string, string>;
    size: number;
    duration?: number;
  };
}

class OfflineStorageService {
  private readonly STORAGE_KEY = '@education_offline_content';
  private readonly CACHE_DIR = `${RNFS.DocumentDirectoryPath}/education_cache`;
  private readonly MAX_STORAGE_MB = 500; // 500MB limit
  private readonly TTL_DAYS = 7;

  async initialize(): Promise<void> {
    // Create cache directory if not exists
    const dirExists = await RNFS.exists(this.CACHE_DIR);
    if (!dirExists) {
      await RNFS.mkdir(this.CACHE_DIR);
    }

    // Clean expired content on init
    await this.cleanExpiredContent();
  }

  async downloadContent(contentId: string, type: 'article' | 'video', url: string): Promise<void> {
    // Check storage quota
    const storageAvailable = await this.checkStorageQuota();
    if (!storageAvailable) {
      throw new Error('STORAGE_QUOTA_EXCEEDED');
    }

    // Download file
    const fileName = `${contentId}.${type === 'video' ? 'mp4' : 'json'}`;
    const filePath = `${this.CACHE_DIR}/${fileName}`;

    const downloadResult = await RNFS.downloadFile({
      fromUrl: url,
      toFile: filePath,
      background: true,
      progressDivider: 10,
      progress: (res) => {
        const progress = (res.bytesWritten / res.contentLength) * 100;
        this.emitDownloadProgress(contentId, progress);
      }
    }).promise;

    if (downloadResult.statusCode === 200) {
      // Store metadata
      const cachedContent: CachedContent = {
        id: contentId,
        type,
        downloadedAt: new Date().toISOString(),
        expiresAt: this.calculateExpiryDate(),
        filePath,
        metadata: await this.extractMetadata(contentId, type)
      };

      await this.addToCache(cachedContent);
    } else {
      throw new Error('DOWNLOAD_FAILED');
    }
  }

  async getOfflineContent(contentId: string): Promise<any> {
    const cache = await this.getCache();
    const cached = cache.find(c => c.id === contentId);

    if (!cached) {
      throw new Error('CONTENT_NOT_CACHED');
    }

    // Check expiry
    if (new Date(cached.expiresAt) < new Date()) {
      await this.removeFromCache(contentId);
      throw new Error('CONTENT_EXPIRED');
    }

    // Read file
    const fileExists = await RNFS.exists(cached.filePath);
    if (!fileExists) {
      await this.removeFromCache(contentId);
      throw new Error('FILE_NOT_FOUND');
    }

    if (cached.type === 'article') {
      const content = await RNFS.readFile(cached.filePath, 'utf8');
      return JSON.parse(content);
    } else {
      // Return local file path for video player
      return { filePath: cached.filePath };
    }
  }

  async deleteContent(contentId: string): Promise<void> {
    const cache = await this.getCache();
    const cached = cache.find(c => c.id === contentId);

    if (cached) {
      // Delete file
      const fileExists = await RNFS.exists(cached.filePath);
      if (fileExists) {
        await RNFS.unlink(cached.filePath);
      }

      // Remove from cache
      await this.removeFromCache(contentId);
    }
  }

  async getStorageStats(): Promise<{ used: number; available: number; total: number }> {
    const cache = await this.getCache();
    let usedBytes = 0;

    for (const item of cache) {
      const stat = await RNFS.stat(item.filePath);
      usedBytes += stat.size;
    }

    return {
      used: usedBytes,
      available: this.MAX_STORAGE_MB * 1024 * 1024 - usedBytes,
      total: this.MAX_STORAGE_MB * 1024 * 1024
    };
  }

  private calculateExpiryDate(): string {
    const expiryDate = new Date();
    expiryDate.setDate(expiryDate.getDate() + this.TTL_DAYS);
    return expiryDate.toISOString();
  }

  private async cleanExpiredContent(): Promise<void> {
    const cache = await this.getCache();
    const now = new Date();

    for (const item of cache) {
      if (new Date(item.expiresAt) < now) {
        await this.deleteContent(item.id);
      }
    }
  }

  private async checkStorageQuota(): Promise<boolean> {
    const stats = await this.getStorageStats();
    return stats.available > 50 * 1024 * 1024; // At least 50MB free
  }
}
```

### Background Sync Service

**Sync Queue Management:**
```typescript
// frontend/src/services/backgroundSyncService.ts
import BackgroundFetch from 'react-native-background-fetch';
import NetInfo from '@react-native-community/netinfo';

interface SyncOperation {
  id: string;
  type: 'progress' | 'quiz' | 'achievement';
  timestamp: string;
  payload: any;
  retries: number;
}

class BackgroundSyncService {
  private readonly SYNC_QUEUE_KEY = '@education_sync_queue';
  private readonly MAX_RETRIES = 3;

  async initialize(): Promise<void> {
    // Configure background fetch
    await BackgroundFetch.configure({
      minimumFetchInterval: 15, // 15 minutes
      stopOnTerminate: false,
      startOnBoot: true,
      enableHeadless: true
    }, async (taskId) => {
      console.log('[BackgroundSync] Task started:', taskId);
      await this.performSync();
      BackgroundFetch.finish(taskId);
    }, (taskId) => {
      console.log('[BackgroundSync] Task timeout:', taskId);
      BackgroundFetch.finish(taskId);
    });

    // Start background fetch
    BackgroundFetch.start();
  }

  async queueOperation(type: string, payload: any): Promise<void> {
    const operation: SyncOperation = {
      id: `${type}_${Date.now()}`,
      type: type as any,
      timestamp: new Date().toISOString(),
      payload,
      retries: 0
    };

    const queue = await this.getSyncQueue();
    queue.push(operation);
    await this.saveSyncQueue(queue);

    // Try immediate sync if online
    const netInfo = await NetInfo.fetch();
    if (netInfo.isConnected) {
      await this.performSync();
    }
  }

  async performSync(): Promise<void> {
    const netInfo = await NetInfo.fetch();
    if (!netInfo.isConnected) {
      console.log('[BackgroundSync] No connectivity, skipping sync');
      return;
    }

    const queue = await this.getSyncQueue();
    if (queue.length === 0) {
      console.log('[BackgroundSync] Queue empty, nothing to sync');
      return;
    }

    console.log(`[BackgroundSync] Syncing ${queue.length} operations`);
    const successfulOperations: string[] = [];

    for (const operation of queue) {
      try {
        await this.syncOperation(operation);
        successfulOperations.push(operation.id);
      } catch (error) {
        console.error('[BackgroundSync] Operation failed:', operation.id, error);

        // Increment retry count
        operation.retries += 1;

        // Remove if max retries reached
        if (operation.retries >= this.MAX_RETRIES) {
          console.log('[BackgroundSync] Max retries reached, removing:', operation.id);
          successfulOperations.push(operation.id);
        }
      }
    }

    // Remove successful operations from queue
    const remainingQueue = queue.filter(op => !successfulOperations.includes(op.id));
    await this.saveSyncQueue(remainingQueue);

    console.log(`[BackgroundSync] Sync complete: ${successfulOperations.length} succeeded, ${remainingQueue.length} remaining`);
  }

  private async syncOperation(operation: SyncOperation): Promise<void> {
    switch (operation.type) {
      case 'progress':
        await educationService.syncProgress(operation.payload);
        break;
      case 'quiz':
        await educationService.syncQuizSubmission(operation.payload);
        break;
      case 'achievement':
        await educationService.syncAchievement(operation.payload);
        break;
      default:
        throw new Error(`Unknown operation type: ${operation.type}`);
    }
  }

  private async getSyncQueue(): Promise<SyncOperation[]> {
    const json = await AsyncStorage.getItem(this.SYNC_QUEUE_KEY);
    return json ? JSON.parse(json) : [];
  }

  private async saveSyncQueue(queue: SyncOperation[]): Promise<void> {
    await AsyncStorage.setItem(this.SYNC_QUEUE_KEY, JSON.stringify(queue));
  }
}
```

### Download Manager UI

**Download Manager Screen:**
```tsx
// frontend/src/screens/education/DownloadManagerScreen.tsx
import React, { useEffect, useState } from 'react';
import { View, Text, FlatList, TouchableOpacity, Alert } from 'react-native';
import { useSelector, useDispatch } from 'react-redux';

export const DownloadManagerScreen: React.FC = () => {
  const [storageStats, setStorageStats] = useState({ used: 0, total: 0, available: 0 });
  const [downloads, setDownloads] = useState<CachedContent[]>([]);

  useEffect(() => {
    loadDownloads();
    loadStorageStats();
  }, []);

  const loadDownloads = async () => {
    const cached = await offlineStorageService.getCache();
    setDownloads(cached);
  };

  const loadStorageStats = async () => {
    const stats = await offlineStorageService.getStorageStats();
    setStorageStats(stats);
  };

  const handleDelete = async (contentId: string) => {
    Alert.alert(
      'Delete Content',
      'Are you sure you want to delete this downloaded content?',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Delete',
          style: 'destructive',
          onPress: async () => {
            await offlineStorageService.deleteContent(contentId);
            await loadDownloads();
            await loadStorageStats();
          }
        }
      ]
    );
  };

  const formatBytes = (bytes: number): string => {
    return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
  };

  return (
    <View style={styles.container}>
      {/* Storage stats card */}
      <View style={styles.statsCard}>
        <Text style={styles.statsTitle}>Storage Usage</Text>
        <View style={styles.progressBar}>
          <View
            style={[
              styles.progressFill,
              { width: `${(storageStats.used / storageStats.total) * 100}%` }
            ]}
          />
        </View>
        <Text style={styles.statsText}>
          {formatBytes(storageStats.used)} / {formatBytes(storageStats.total)} used
        </Text>
        <Text style={styles.statsSubtext}>
          {formatBytes(storageStats.available)} available
        </Text>
      </View>

      {/* Downloaded content list */}
      <FlatList
        data={downloads}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <View style={styles.downloadItem}>
            <View style={styles.itemInfo}>
              <Text style={styles.itemTitle}>{item.metadata.title.en}</Text>
              <Text style={styles.itemMeta}>
                {item.type === 'video' ? 'Video' : 'Article'} · {formatBytes(item.metadata.size)}
              </Text>
              <Text style={styles.itemExpiry}>
                Expires: {new Date(item.expiresAt).toLocaleDateString()}
              </Text>
            </View>
            <TouchableOpacity
              style={styles.deleteButton}
              onPress={() => handleDelete(item.id)}
            >
              <Text style={styles.deleteButtonText}>Delete</Text>
            </TouchableOpacity>
          </View>
        )}
        ListEmptyComponent={
          <View style={styles.emptyState}>
            <Text style={styles.emptyText}>No downloaded content</Text>
            <Text style={styles.emptySubtext}>
              Download articles and videos for offline access
            </Text>
          </View>
        }
      />
    </View>
  );
};
```

**Download Button Component:**
```tsx
// frontend/src/components/education/DownloadButton.tsx
import React, { useState, useEffect } from 'react';
import { TouchableOpacity, Text, ActivityIndicator, View } from 'react-native';
import Icon from 'react-native-vector-icons/MaterialIcons';

interface DownloadButtonProps {
  contentId: string;
  contentType: 'article' | 'video';
  downloadUrl: string;
}

export const DownloadButton: React.FC<DownloadButtonProps> = ({
  contentId,
  contentType,
  downloadUrl
}) => {
  const [isDownloaded, setIsDownloaded] = useState(false);
  const [isDownloading, setIsDownloading] = useState(false);
  const [progress, setProgress] = useState(0);

  useEffect(() => {
    checkDownloadStatus();
  }, [contentId]);

  const checkDownloadStatus = async () => {
    const cached = await offlineStorageService.isContentCached(contentId);
    setIsDownloaded(cached);
  };

  const handleDownload = async () => {
    setIsDownloading(true);

    // Subscribe to progress
    const unsubscribe = offlineStorageService.onDownloadProgress(contentId, (percent) => {
      setProgress(percent);
    });

    try {
      await offlineStorageService.downloadContent(contentId, contentType, downloadUrl);
      setIsDownloaded(true);
    } catch (error) {
      Alert.alert('Download Failed', error.message);
    } finally {
      setIsDownloading(false);
      unsubscribe();
    }
  };

  const handleDelete = async () => {
    await offlineStorageService.deleteContent(contentId);
    setIsDownloaded(false);
  };

  if (isDownloading) {
    return (
      <View style={styles.progressContainer}>
        <ActivityIndicator size="small" />
        <Text style={styles.progressText}>{Math.round(progress)}%</Text>
      </View>
    );
  }

  if (isDownloaded) {
    return (
      <TouchableOpacity style={styles.downloadedButton} onPress={handleDelete}>
        <Icon name="check-circle" size={20} color="#4CAF50" />
        <Text style={styles.downloadedText}>Downloaded</Text>
      </TouchableOpacity>
    );
  }

  return (
    <TouchableOpacity style={styles.downloadButton} onPress={handleDownload}>
      <Icon name="download" size={20} color="#2196F3" />
      <Text style={styles.downloadText}>Download</Text>
    </TouchableOpacity>
  );
};
```

### Files to Create/Modify

**Frontend:**
```
frontend/src/
├── services/
│   ├── offlineStorageService.ts
│   └── backgroundSyncService.ts
├── screens/education/
│   └── DownloadManagerScreen.tsx
├── components/education/
│   ├── DownloadButton.tsx
│   ├── OfflineIndicator.tsx
│   └── StorageStatsCard.tsx
├── hooks/
│   ├── useOfflineContent.ts
│   └── useNetworkStatus.ts
└── utils/
    ├── storageUtils.ts
    └── syncUtils.ts
```

**Backend (extend Task 031):**
```
backend/src/
├── controllers/education/
│   └── SyncController.ts
└── services/education/
    └── BatchSyncService.ts
```

## Dependencies

**External:**
- [ ] Task 031 backend API endpoints (content, progress, quiz)
- [ ] Task 032 UI components (content detail screen)
- [ ] AWS CloudFront CDN for content delivery
- [ ] Backend batch sync API endpoints

**Internal:**
- [ ] React Native AsyncStorage for metadata
- [ ] React Native File System (RNFS) for file storage
- [ ] React Native Background Fetch for sync tasks
- [ ] NetInfo for connectivity detection
- [ ] Existing offline infrastructure (if any)

**NPM Packages:**
```json
{
  "@react-native-async-storage/async-storage": "^1.19.0",
  "react-native-fs": "^2.20.0",
  "react-native-background-fetch": "^4.1.0",
  "@react-native-community/netinfo": "^9.4.0"
}
```

## Effort Estimate

- **Size:** M (Medium)
- **Hours:** 48 hours
- **Breakdown:**
  - Offline storage service: 12 hours
  - Background sync service: 12 hours
  - Download manager UI: 10 hours
  - Download button and progress UI: 6 hours
  - Storage management and cleanup: 8 hours
- **Parallel:** true (can work after Task 031 API and Task 032 UI foundation complete)

## Definition of Done

- [ ] Content downloads work for articles and videos
- [ ] Downloaded content accessible offline
- [ ] Progress tracked offline and synced when online
- [ ] Download manager UI shows all cached content
- [ ] Storage quota management prevents overflow
- [ ] Background sync runs periodically without draining battery
- [ ] Offline indicator displayed when no connectivity
- [ ] TTL expiry automatically removes old content
- [ ] Unit tests written (>75% coverage)
- [ ] Integration tests for sync logic
- [ ] Code reviewed and approved
- [ ] Tested on iOS and Android devices
- [ ] Tested in airplane mode and poor connectivity
- [ ] Merged to development branch

## Testing Requirements

**Unit Tests:**
- OfflineStorageService caching logic
- BackgroundSyncService queue management
- Storage quota calculations
- TTL expiry logic

**Integration Tests:**
- Full download flow (initiate → progress → complete)
- Background sync after reconnection
- Progress tracking offline and sync
- Quiz submission offline and sync
- Storage cleanup on TTL expiry

**Manual Testing:**
- Download content in airplane mode (should queue)
- Use app offline for extended period
- Verify content expires after 7 days
- Test on low-storage devices
- Verify battery usage acceptable (< 5% per day)
- Test download interruption and resume
