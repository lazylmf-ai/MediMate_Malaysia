---
name: Content Management & Admin Tools
status: open
created: 2025-10-01T11:05:51Z
updated: 2025-10-01T11:05:51Z
github: [Will be updated when synced to GitHub]
depends_on: [031]
parallel: true
conflicts_with: []
---

# Task 036: Content Management & Admin Tools

## Description

Build a comprehensive content management system (CMS) and admin tools for creating, reviewing, and publishing educational content. This includes a medical review workflow, multi-language content editor, publishing pipeline, and analytics dashboard. This system enables content teams and medical reviewers to maintain high-quality, culturally appropriate health education materials.

**Scope:**
- Simple admin UI for content creation and editing
- Medical review workflow (assign reviewers, track approval status)
- Multi-language content editor with translation management
- Publishing pipeline (draft → review → publish)
- Content analytics dashboard (views, engagement, user feedback)
- Content versioning and audit trail
- Role-based access control (admin, content creator, medical reviewer)

## Acceptance Criteria

- [ ] Admin panel accessible at `/admin/education` with role-based authentication
- [ ] Content creation form with WYSIWYG editor for all 4 languages
- [ ] Content can be saved as draft, submitted for review, or published
- [ ] Medical reviewers receive notifications when content assigned for review
- [ ] Reviewers can approve or request changes with comments
- [ ] Content versioning tracks all changes with audit trail
- [ ] Multi-language editor shows translation status for each language
- [ ] Publishing workflow enforces review before content goes live
- [ ] Analytics dashboard shows content performance metrics
- [ ] Content can be archived or unpublished without deletion
- [ ] Bulk operations supported (publish multiple, assign reviewers)
- [ ] Search and filter content by status, category, language, author

## Technical Details

### Admin Panel Architecture

**Admin Routes:**
```typescript
// backend/src/routes/admin/education.ts
import express from 'express';
import { requireRole } from '@/middleware/authorization';

const router = express.Router();

// Content management
router.get('/content', requireRole(['admin', 'content_creator']), adminController.listContent);
router.get('/content/:id', requireRole(['admin', 'content_creator', 'medical_reviewer']), adminController.getContent);
router.post('/content', requireRole(['admin', 'content_creator']), adminController.createContent);
router.put('/content/:id', requireRole(['admin', 'content_creator']), adminController.updateContent);
router.delete('/content/:id', requireRole(['admin']), adminController.deleteContent);

// Review workflow
router.post('/content/:id/submit-review', requireRole(['content_creator']), adminController.submitForReview);
router.post('/content/:id/assign-reviewer', requireRole(['admin']), adminController.assignReviewer);
router.post('/content/:id/approve', requireRole(['medical_reviewer']), adminController.approveContent);
router.post('/content/:id/request-changes', requireRole(['medical_reviewer']), adminController.requestChanges);

// Publishing
router.post('/content/:id/publish', requireRole(['admin', 'medical_reviewer']), adminController.publishContent);
router.post('/content/:id/unpublish', requireRole(['admin']), adminController.unpublishContent);
router.post('/content/:id/archive', requireRole(['admin']), adminController.archiveContent);

// Analytics
router.get('/analytics/overview', requireRole(['admin']), adminController.getAnalyticsOverview);
router.get('/analytics/content/:id', requireRole(['admin', 'content_creator']), adminController.getContentAnalytics);

// Translation management
router.get('/content/:id/translations', requireRole(['admin', 'content_creator']), adminController.getTranslationStatus);
router.put('/content/:id/translations/:language', requireRole(['content_creator']), adminController.updateTranslation);

export default router;
```

**Database Schema Extensions:**
```sql
-- backend/database/migrations/010_education_admin.sql

-- Content status and workflow
ALTER TABLE education_content
ADD COLUMN status VARCHAR(20) DEFAULT 'draft' NOT NULL CHECK (status IN ('draft', 'in_review', 'approved', 'published', 'archived')),
ADD COLUMN author_id UUID REFERENCES users(id),
ADD COLUMN reviewer_id UUID REFERENCES users(id),
ADD COLUMN review_notes TEXT,
ADD COLUMN published_at TIMESTAMP,
ADD COLUMN archived_at TIMESTAMP,
ADD COLUMN version INTEGER DEFAULT 1;

-- Content version history
CREATE TABLE education_content_versions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  content_id UUID REFERENCES education_content(id) ON DELETE CASCADE,
  version INTEGER NOT NULL,
  title JSONB NOT NULL,
  description JSONB NOT NULL,
  body JSONB NOT NULL,
  changed_by UUID REFERENCES users(id),
  changed_at TIMESTAMP DEFAULT NOW(),
  change_note TEXT
);

-- Review comments
CREATE TABLE education_review_comments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  content_id UUID REFERENCES education_content(id) ON DELETE CASCADE,
  reviewer_id UUID REFERENCES users(id),
  comment TEXT NOT NULL,
  status VARCHAR(20) NOT NULL CHECK (status IN ('pending', 'resolved')),
  created_at TIMESTAMP DEFAULT NOW()
);

-- Translation status
CREATE TABLE education_translation_status (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  content_id UUID REFERENCES education_content(id) ON DELETE CASCADE,
  language VARCHAR(5) NOT NULL CHECK (language IN ('ms', 'en', 'zh', 'ta')),
  status VARCHAR(20) NOT NULL CHECK (status IN ('missing', 'draft', 'review', 'approved')),
  translator_id UUID REFERENCES users(id),
  last_updated TIMESTAMP DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_education_content_status ON education_content(status);
CREATE INDEX idx_education_content_author ON education_content(author_id);
CREATE INDEX idx_education_content_reviewer ON education_content(reviewer_id);
CREATE INDEX idx_education_content_versions ON education_content_versions(content_id, version);
```

### Content Editor Implementation

**Admin Content Editor Screen:**
```tsx
// frontend/src/screens/admin/ContentEditorScreen.tsx
import React, { useState, useEffect } from 'react';
import { View, Text, ScrollView, TextInput, TouchableOpacity } from 'react-native';
import { RichTextEditor } from '@/components/admin/RichTextEditor';
import { LanguageTabBar } from '@/components/admin/LanguageTabBar';
import { ContentMetadataForm } from '@/components/admin/ContentMetadataForm';

interface ContentEditorScreenProps {
  route: { params: { contentId?: string } };
  navigation: any;
}

export const ContentEditorScreen: React.FC<ContentEditorScreenProps> = ({ route, navigation }) => {
  const { contentId } = route.params;
  const [isEdit, setIsEdit] = useState(!!contentId);
  const [currentLanguage, setCurrentLanguage] = useState<Language>('en');
  const [content, setContent] = useState<EducationContentDraft>({
    type: 'article',
    category: '',
    title: { ms: '', en: '', zh: '', ta: '' },
    description: { ms: '', en: '', zh: '', ta: '' },
    body: { ms: '', en: '', zh: '', ta: '' },
    metadata: {
      estimatedReadTime: 0,
      difficulty: 'beginner',
      tags: [],
      relatedMedications: [],
      relatedConditions: []
    }
  });
  const [status, setStatus] = useState<'draft' | 'in_review' | 'published'>('draft');
  const [translationStatus, setTranslationStatus] = useState({
    ms: 'missing',
    en: 'draft',
    zh: 'missing',
    ta: 'missing'
  });

  useEffect(() => {
    if (isEdit) {
      loadContent();
    }
  }, [contentId]);

  const loadContent = async () => {
    const data = await adminService.getContent(contentId!);
    setContent(data);
    setStatus(data.status);

    const translations = await adminService.getTranslationStatus(contentId!);
    setTranslationStatus(translations);
  };

  const handleSaveDraft = async () => {
    try {
      if (isEdit) {
        await adminService.updateContent(contentId!, { ...content, status: 'draft' });
      } else {
        const newContent = await adminService.createContent({ ...content, status: 'draft' });
        navigation.setParams({ contentId: newContent.id });
        setIsEdit(true);
      }
      Alert.alert('Success', 'Draft saved successfully');
    } catch (error) {
      Alert.alert('Error', 'Failed to save draft');
    }
  };

  const handleSubmitForReview = async () => {
    // Validate all languages have content
    const missingLanguages = Object.entries(content.title)
      .filter(([lang, title]) => !title || !content.body[lang])
      .map(([lang]) => lang);

    if (missingLanguages.length > 0) {
      Alert.alert(
        'Missing Translations',
        `Please complete content for: ${missingLanguages.join(', ')}`
      );
      return;
    }

    try {
      await adminService.submitForReview(contentId!);
      Alert.alert('Success', 'Content submitted for medical review');
      navigation.goBack();
    } catch (error) {
      Alert.alert('Error', 'Failed to submit for review');
    }
  };

  const handlePublish = async () => {
    try {
      await adminService.publishContent(contentId!);
      Alert.alert('Success', 'Content published successfully');
      navigation.goBack();
    } catch (error) {
      Alert.alert('Error', 'Failed to publish content');
    }
  };

  return (
    <ScrollView style={styles.container}>
      <Text style={styles.title}>{isEdit ? 'Edit Content' : 'Create Content'}</Text>

      {/* Content metadata */}
      <ContentMetadataForm
        content={content}
        onChange={(updates) => setContent({ ...content, ...updates })}
      />

      {/* Language tabs */}
      <LanguageTabBar
        currentLanguage={currentLanguage}
        onLanguageChange={setCurrentLanguage}
        translationStatus={translationStatus}
      />

      {/* Title input */}
      <View style={styles.field}>
        <Text style={styles.label}>Title ({currentLanguage.toUpperCase()})</Text>
        <TextInput
          style={styles.input}
          value={content.title[currentLanguage]}
          onChangeText={(text) => setContent({
            ...content,
            title: { ...content.title, [currentLanguage]: text }
          })}
          placeholder="Enter content title"
        />
      </View>

      {/* Description input */}
      <View style={styles.field}>
        <Text style={styles.label}>Description ({currentLanguage.toUpperCase()})</Text>
        <TextInput
          style={[styles.input, styles.multiline]}
          value={content.description[currentLanguage]}
          onChangeText={(text) => setContent({
            ...content,
            description: { ...content.description, [currentLanguage]: text }
          })}
          placeholder="Enter brief description"
          multiline
          numberOfLines={3}
        />
      </View>

      {/* Rich text editor */}
      <View style={styles.field}>
        <Text style={styles.label}>Content ({currentLanguage.toUpperCase()})</Text>
        <RichTextEditor
          initialContent={content.body[currentLanguage]}
          onChange={(html) => setContent({
            ...content,
            body: { ...content.body, [currentLanguage]: html }
          })}
        />
      </View>

      {/* Action buttons */}
      <View style={styles.actions}>
        <TouchableOpacity style={styles.buttonSecondary} onPress={handleSaveDraft}>
          <Text style={styles.buttonText}>Save Draft</Text>
        </TouchableOpacity>

        {status === 'draft' && (
          <TouchableOpacity style={styles.buttonPrimary} onPress={handleSubmitForReview}>
            <Text style={styles.buttonText}>Submit for Review</Text>
          </TouchableOpacity>
        )}

        {status === 'approved' && (
          <TouchableOpacity style={styles.buttonSuccess} onPress={handlePublish}>
            <Text style={styles.buttonText}>Publish</Text>
          </TouchableOpacity>
        )}
      </View>
    </ScrollView>
  );
};
```

### Medical Review Workflow

**Review Dashboard:**
```tsx
// frontend/src/screens/admin/ReviewDashboardScreen.tsx
export const ReviewDashboardScreen: React.FC = () => {
  const [pendingReviews, setPendingReviews] = useState<ContentReview[]>([]);
  const [myReviews, setMyReviews] = useState<ContentReview[]>([]);

  useEffect(() => {
    loadReviews();
  }, []);

  const loadReviews = async () => {
    const pending = await adminService.getPendingReviews();
    const mine = await adminService.getMyAssignedReviews();
    setPendingReviews(pending);
    setMyReviews(mine);
  };

  const handleAssignReviewer = async (contentId: string, reviewerId: string) => {
    await adminService.assignReviewer(contentId, reviewerId);
    await loadReviews();
  };

  return (
    <ScrollView>
      <Text style={styles.sectionTitle}>Pending Reviews</Text>
      {pendingReviews.map(review => (
        <PendingReviewCard
          key={review.id}
          review={review}
          onAssign={(reviewerId) => handleAssignReviewer(review.id, reviewerId)}
        />
      ))}

      <Text style={styles.sectionTitle}>My Assigned Reviews</Text>
      {myReviews.map(review => (
        <AssignedReviewCard
          key={review.id}
          review={review}
          onReview={() => navigation.navigate('ReviewContent', { contentId: review.id })}
        />
      ))}
    </ScrollView>
  );
};
```

**Review Content Screen:**
```tsx
// frontend/src/screens/admin/ReviewContentScreen.tsx
export const ReviewContentScreen: React.FC = ({ route }) => {
  const { contentId } = route.params;
  const [content, setContent] = useState<EducationContent | null>(null);
  const [comments, setComments] = useState<ReviewComment[]>([]);
  const [newComment, setNewComment] = useState('');

  const handleApprove = async () => {
    Alert.alert(
      'Approve Content',
      'This content will be marked as approved and ready for publishing.',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Approve',
          onPress: async () => {
            await adminService.approveContent(contentId);
            navigation.goBack();
          }
        }
      ]
    );
  };

  const handleRequestChanges = async () => {
    if (!newComment.trim()) {
      Alert.alert('Error', 'Please provide feedback for requested changes');
      return;
    }

    await adminService.requestChanges(contentId, newComment);
    navigation.goBack();
  };

  return (
    <ScrollView>
      {/* Content preview */}
      <ContentPreview content={content} />

      {/* Review comments */}
      <View style={styles.commentsSection}>
        <Text style={styles.sectionTitle}>Review Comments</Text>
        {comments.map(comment => (
          <CommentCard key={comment.id} comment={comment} />
        ))}

        <TextInput
          style={styles.commentInput}
          value={newComment}
          onChangeText={setNewComment}
          placeholder="Add review comment..."
          multiline
        />
      </View>

      {/* Actions */}
      <View style={styles.actions}>
        <TouchableOpacity style={styles.buttonWarning} onPress={handleRequestChanges}>
          <Text style={styles.buttonText}>Request Changes</Text>
        </TouchableOpacity>
        <TouchableOpacity style={styles.buttonSuccess} onPress={handleApprove}>
          <Text style={styles.buttonText}>Approve</Text>
        </TouchableOpacity>
      </View>
    </ScrollView>
  );
};
```

### Analytics Dashboard

**Content Analytics Service:**
```typescript
// backend/src/services/education/ContentAnalyticsService.ts
class ContentAnalyticsService {
  /**
   * Get overview analytics for all content
   */
  async getOverviewAnalytics(): Promise<AnalyticsOverview> {
    const totalContent = await this.getTotalContentCount();
    const totalViews = await this.getTotalViews();
    const totalCompletions = await this.getTotalCompletions();
    const averageEngagement = await this.getAverageEngagement();
    const topContent = await this.getTopContent(10);
    const contentByStatus = await this.getContentByStatus();

    return {
      totalContent,
      totalViews,
      totalCompletions,
      averageEngagement,
      topContent,
      contentByStatus,
      viewsByMonth: await this.getViewsByMonth(12)
    };
  }

  /**
   * Get detailed analytics for specific content
   */
  async getContentAnalytics(contentId: string): Promise<ContentAnalytics> {
    const views = await this.getContentViews(contentId);
    const completions = await this.getContentCompletions(contentId);
    const averageTimeSpent = await this.getAverageTimeSpent(contentId);
    const userRatings = await this.getUserRatings(contentId);
    const shareCount = await this.getShareCount(contentId);
    const viewsByLanguage = await this.getViewsByLanguage(contentId);
    const viewsByDate = await this.getViewsByDate(contentId, 30);

    return {
      contentId,
      views,
      completions,
      completionRate: completions / views,
      averageTimeSpent,
      averageRating: this.calculateAverageRating(userRatings),
      shareCount,
      viewsByLanguage,
      viewsByDate
    };
  }

  /**
   * Track content view event
   */
  async trackView(contentId: string, userId: string, language: string): Promise<void> {
    await db.query(`
      INSERT INTO education_analytics_views (content_id, user_id, language, viewed_at)
      VALUES ($1, $2, $3, NOW())
    `, [contentId, userId, language]);

    // Update denormalized view count
    await db.query(`
      UPDATE education_content
      SET view_count = view_count + 1
      WHERE id = $1
    `, [contentId]);
  }

  /**
   * Track content completion event
   */
  async trackCompletion(contentId: string, userId: string, timeSpent: number): Promise<void> {
    await db.query(`
      INSERT INTO education_analytics_completions (content_id, user_id, time_spent_seconds, completed_at)
      VALUES ($1, $2, $3, NOW())
    `, [contentId, userId, timeSpent]);

    // Update denormalized completion count
    await db.query(`
      UPDATE education_content
      SET completion_count = completion_count + 1
      WHERE id = $1
    `, [contentId]);
  }
}
```

**Analytics Dashboard Screen:**
```tsx
// frontend/src/screens/admin/AnalyticsDashboardScreen.tsx
export const AnalyticsDashboardScreen: React.FC = () => {
  const [analytics, setAnalytics] = useState<AnalyticsOverview | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadAnalytics();
  }, []);

  const loadAnalytics = async () => {
    const data = await adminService.getAnalyticsOverview();
    setAnalytics(data);
    setLoading(false);
  };

  if (loading) return <LoadingSpinner />;

  return (
    <ScrollView>
      {/* Overview cards */}
      <View style={styles.statsGrid}>
        <StatCard
          title="Total Content"
          value={analytics.totalContent}
          icon="library-books"
        />
        <StatCard
          title="Total Views"
          value={analytics.totalViews.toLocaleString()}
          icon="visibility"
        />
        <StatCard
          title="Completions"
          value={analytics.totalCompletions.toLocaleString()}
          icon="check-circle"
        />
        <StatCard
          title="Engagement Rate"
          value={`${(analytics.averageEngagement * 100).toFixed(1)}%`}
          icon="trending-up"
        />
      </View>

      {/* Views by month chart */}
      <View style={styles.chartSection}>
        <Text style={styles.sectionTitle}>Views by Month</Text>
        <LineChart
          data={analytics.viewsByMonth}
          width={Dimensions.get('window').width - 40}
          height={220}
          chartConfig={chartConfig}
        />
      </View>

      {/* Top performing content */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Top Performing Content</Text>
        {analytics.topContent.map((content, index) => (
          <TopContentCard key={content.id} content={content} rank={index + 1} />
        ))}
      </View>

      {/* Content by status */}
      <View style={styles.chartSection}>
        <Text style={styles.sectionTitle}>Content by Status</Text>
        <PieChart
          data={analytics.contentByStatus}
          width={Dimensions.get('window').width - 40}
          height={220}
          chartConfig={chartConfig}
        />
      </View>
    </ScrollView>
  );
};
```

### Files to Create/Modify

**Backend:**
```
backend/src/
├── routes/admin/
│   └── education.ts
├── controllers/admin/
│   └── EducationAdminController.ts
├── services/education/
│   ├── ContentManagementService.ts
│   ├── ReviewWorkflowService.ts
│   ├── ContentAnalyticsService.ts
│   └── TranslationManagementService.ts
├── middleware/
│   └── authorization.ts
└── database/migrations/
    └── 010_education_admin.sql
```

**Frontend (Web Admin Panel):**
```
frontend/src/
├── screens/admin/
│   ├── ContentListScreen.tsx
│   ├── ContentEditorScreen.tsx
│   ├── ReviewDashboardScreen.tsx
│   ├── ReviewContentScreen.tsx
│   └── AnalyticsDashboardScreen.tsx
├── components/admin/
│   ├── RichTextEditor.tsx
│   ├── LanguageTabBar.tsx
│   ├── ContentMetadataForm.tsx
│   ├── PendingReviewCard.tsx
│   ├── AssignedReviewCard.tsx
│   ├── ContentPreview.tsx
│   ├── CommentCard.tsx
│   ├── StatCard.tsx
│   └── TopContentCard.tsx
└── services/
    └── adminService.ts
```

## Dependencies

**External:**
- [ ] Task 031 backend infrastructure (database, API)
- [ ] Existing authentication system (OAuth 2.0)
- [ ] Existing role-based access control
- [ ] AWS S3 for content media storage

**Internal:**
- [ ] React Native Web for admin panel (or separate web app)
- [ ] Rich text editor library (e.g., react-quill, draft-js)
- [ ] Chart library (e.g., react-native-chart-kit)
- [ ] Redux for admin state management

**NPM Packages:**
```json
{
  "react-quill": "^2.0.0",
  "react-native-chart-kit": "^6.12.0",
  "react-native-svg": "^13.9.0"
}
```

## Effort Estimate

- **Size:** L (Large)
- **Hours:** 64 hours
- **Breakdown:**
  - Content editor UI: 16 hours
  - Review workflow: 14 hours
  - Publishing pipeline: 10 hours
  - Analytics dashboard: 14 hours
  - Translation management: 10 hours
- **Parallel:** true (can work after Task 031 backend infrastructure complete)

## Definition of Done

- [ ] Admin panel accessible with role-based authentication
- [ ] Content creation and editing functional for all languages
- [ ] Review workflow complete (assign, approve, request changes)
- [ ] Publishing pipeline enforces review before publish
- [ ] Analytics dashboard displays all metrics
- [ ] Content versioning tracks changes
- [ ] Translation status visible and manageable
- [ ] Bulk operations work (publish multiple, assign reviewers)
- [ ] Search and filter content working
- [ ] Unit tests written (>75% coverage)
- [ ] Integration tests for workflow
- [ ] Code reviewed and approved
- [ ] Tested by content team and medical reviewers
- [ ] User documentation created
- [ ] Merged to development branch

## Testing Requirements

**Unit Tests:**
- ContentManagementService CRUD operations
- ReviewWorkflowService state transitions
- ContentAnalyticsService metric calculations
- TranslationManagementService status tracking

**Integration Tests:**
- Full content creation → review → publish workflow
- Review assignment and notification
- Content versioning on updates
- Analytics tracking (view, completion events)
- Translation status updates
- Role-based access control enforcement

**Manual Testing:**
- Create content as content creator
- Submit for review and verify reviewer notification
- Review content and approve/request changes
- Publish approved content and verify live
- Verify analytics data accuracy
- Test multi-language content editing
- Test bulk operations performance
- Verify audit trail completeness
